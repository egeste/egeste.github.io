<!-- Animated mesh background -->
<div class="mesh-background" aria-hidden="true">
  <canvas id="mesh-canvas"></canvas>
</div>

<script>
  // Animated mesh network background
  class MeshNetwork {
    constructor() {
      this.canvas = document.getElementById('mesh-canvas');
      this.ctx = this.canvas.getContext('2d');
      this.nodes = [];
      this.maxNodes = 80;
      this.maxDistance = 300;
      this.animationId = null;
      
      this.init();
      this.createNodes();
      this.animate();
      this.handleResize();
      this.handleClicks();
    }
    
    init() {
      this.resize();
    }
    
    resize() {
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
    }
    
    createNodes() {
      this.nodes = [];
      for (let i = 0; i < this.maxNodes; i++) {
        this.nodes.push(this.createNode());
      }
    }
    
    createNode(x = null, y = null) {
      const now = Date.now();
      return {
        x: x !== null ? x : Math.random() * this.canvas.width,
        y: y !== null ? y : Math.random() * this.canvas.height,
        vx: (Math.random() - 0.5) * 0.8,
        vy: (Math.random() - 0.5) * 0.8,
        radius: Math.random() * 3 + 1.5,
        birthTime: now,
        lifetime: Math.random() * 25000 + 5000, // 5-30 seconds
        opacity: 0,
        fadeInDuration: 1000, // 1 second fade in
        fadeOutDuration: 2000 // 2 second fade out
      };
    }
    
    updateNodes() {
      const now = Date.now();
      
      // Update existing nodes
      for (let i = this.nodes.length - 1; i >= 0; i--) {
        const node = this.nodes[i];
        
        // Update position
        node.x += node.vx;
        node.y += node.vy;
        
        // Bounce off edges
        if (node.x < 0 || node.x > this.canvas.width) node.vx *= -1;
        if (node.y < 0 || node.y > this.canvas.height) node.vy *= -1;
        
        // Update opacity based on lifetime
        const age = now - node.birthTime;
        const timeUntilDeath = node.lifetime - age;
        
        if (age < node.fadeInDuration) {
          // Fading in
          node.opacity = age / node.fadeInDuration;
        } else if (timeUntilDeath < node.fadeOutDuration) {
          // Fading out
          node.opacity = Math.max(0, timeUntilDeath / node.fadeOutDuration);
        } else {
          // Fully visible
          node.opacity = 1;
        }
        
        // Remove dead nodes
        if (age >= node.lifetime) {
          this.nodes.splice(i, 1);
        }
      }
      
      // Only add new nodes if we're below the target count
      // This allows natural equilibrium through organic death cycles
      if (this.nodes.length < this.maxNodes) {
        this.nodes.push(this.createNode());
      }
    }
    
    drawNodes() {
      this.nodes.forEach(node => {
        if (node.opacity <= 0) return;
        
        // Outer glow
        this.ctx.beginPath();
        this.ctx.arc(node.x, node.y, node.radius + 2, 0, Math.PI * 2);
        this.ctx.fillStyle = `rgba(139, 92, 246, ${0.2 * node.opacity})`;
        this.ctx.fill();
        
        // Main node
        this.ctx.beginPath();
        this.ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
        this.ctx.fillStyle = `rgba(139, 92, 246, ${0.8 * node.opacity})`;
        this.ctx.fill();
      });
    }
    
    drawConnections() {
      for (let i = 0; i < this.nodes.length; i++) {
        for (let j = i + 1; j < this.nodes.length; j++) {
          const nodeA = this.nodes[i];
          const nodeB = this.nodes[j];
          
          // Skip if either node is invisible
          if (nodeA.opacity <= 0 || nodeB.opacity <= 0) continue;
          
          const dx = nodeA.x - nodeB.x;
          const dy = nodeA.y - nodeB.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < this.maxDistance) {
            const distanceOpacity = (1 - distance / this.maxDistance) * 0.6;
            const nodeOpacity = Math.min(nodeA.opacity, nodeB.opacity);
            const finalOpacity = distanceOpacity * nodeOpacity;
            
            this.ctx.strokeStyle = `rgba(139, 92, 246, ${finalOpacity})`;
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.moveTo(nodeA.x, nodeA.y);
            this.ctx.lineTo(nodeB.x, nodeB.y);
            this.ctx.stroke();
          }
        }
      }
    }
    
    animate() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.updateNodes();
      this.drawConnections();
      this.drawNodes();
      this.animationId = requestAnimationFrame(() => this.animate());
    }
    
    handleResize() {
      window.addEventListener('resize', () => {
        this.resize();
        this.createNodes();
      });
    }
    
    handleClicks() {
      document.addEventListener('click', (event) => {
        // Get mouse position relative to the viewport
        const x = event.clientX;
        const y = event.clientY;
        this.addNode(x, y);
      });
    }
    
    addNode(x, y) {
      this.nodes.push(this.createNode(x, y));
    }
    
    destroy() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
    }
  }
  
  // Initialize when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    const mesh = new MeshNetwork();
    
    // Handle reduced motion preference
    if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
      mesh.destroy();
      document.querySelector('.mesh-background').style.display = 'none';
    }
  });
</script>